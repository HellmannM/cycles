// Copyright 2021 The Khronos Group
// SPDX-License-Identifier: Apache-2.0

// This file was generated by generate_queries.py
// Don't make changes to this directly

#include <stdint.h>
#include <math.h>
#include <anari/anari.h>
namespace cycles {
static int subtype_hash(const char *str) {
   static const uint32_t table[] = {0x66650011u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610018u,0x0u,0x7372001du,0x66650029u,0x0u,0x0u,0x71700034u,0x7372003au,0x67660012u,0x62610013u,0x76750014u,0x6d6c0015u,0x75740016u,0x1000017u,0x80000000u,0x75740019u,0x7574001au,0x6665001bu,0x100001cu,0x80000001u,0x7574001eu,0x6968001fu,0x706f0020u,0x68670021u,0x73720022u,0x62610023u,0x71700024u,0x69680025u,0x6a690026u,0x64630027u,0x1000028u,0x80000002u,0x7372002au,0x7473002bu,0x7170002cu,0x6665002du,0x6463002eu,0x7574002fu,0x6a690030u,0x77760031u,0x66650032u,0x1000033u,0x80000003u,0x69680035u,0x66650036u,0x73720037u,0x66650038u,0x1000039u,0x80000004u,0x6a69003bu,0x6261003cu,0x6f6e003du,0x6867003eu,0x6d6c003fu,0x66650040u,0x1000041u,0x80000005u};
   uint32_t cur = 0x75640000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = (uint32_t)str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
static int param_hash(const char *str) {
   static const uint32_t table[] = {0x746c0017u,0x6261006bu,0x70610075u,0x6a69009fu,0x0u,0x706100a8u,0x736500dau,0x666500f3u,0x6f6d00f9u,0x0u,0x0u,0x6a690121u,0x62610126u,0x6661012eu,0x71700139u,0x736f0140u,0x0u,0x66610181u,0x76690192u,0x7372021eu,0x71700227u,0x70650229u,0x706f0282u,0x7170001fu,0x63620037u,0x0u,0x0u,0x66650059u,0x0u,0x0u,0x71700066u,0x69680020u,0x62610021u,0x4e430022u,0x7675002du,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f0033u,0x7574002eu,0x706f002fu,0x67660030u,0x67660031u,0x1000032u,0x80000000u,0x65640034u,0x66650035u,0x1000036u,0x80000001u,0x6a690038u,0x66650039u,0x6f6e003au,0x7574003bu,0x5343003cu,0x706f004cu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610051u,0x6d6c004du,0x706f004eu,0x7372004fu,0x1000050u,0x80000002u,0x65640052u,0x6a690053u,0x62610054u,0x6f6e0055u,0x64630056u,0x66650057u,0x1000058u,0x80000003u,0x7372005au,0x7574005bu,0x7675005cu,0x7372005du,0x6665005eu,0x5352005fu,0x62610060u,0x65640061u,0x6a690062u,0x76750063u,0x74730064u,0x1000065u,0x80000004u,0x66650067u,0x64630068u,0x75740069u,0x100006au,0x80000005u,0x6463006cu,0x6c6b006du,0x6867006eu,0x7372006fu,0x706f0070u,0x76750071u,0x6f6e0072u,0x65640073u,0x1000074u,0x80000006u,0x6e6d0084u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610089u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6d6c009bu,0x66650085u,0x73720086u,0x62610087u,0x1000088u,0x80000007u,0x6f6e008au,0x6f6e008bu,0x6665008cu,0x6d6c008du,0x2f2e008eu,0x6563008fu,0x706f0091u,0x66650096u,0x6d6c0092u,0x706f0093u,0x73720094u,0x1000095u,0x80000008u,0x71700097u,0x75740098u,0x69680099u,0x100009au,0x80000009u,0x706f009cu,0x7372009du,0x100009eu,0x8000000au,0x737200a0u,0x666500a1u,0x646300a2u,0x757400a3u,0x6a6900a4u,0x706f00a5u,0x6f6e00a6u,0x10000a7u,0x8000000bu,0x737200b7u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x776300b9u,0x10000b8u,0x8000000cu,0x767500cdu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7a7900d8u,0x747300ceu,0x454400cfu,0x6a6900d0u,0x747300d1u,0x757400d2u,0x626100d3u,0x6f6e00d4u,0x646300d5u,0x666500d6u,0x10000d7u,0x8000000du,0x10000d9u,0x8000000eu,0x706f00e8u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f00efu,0x6e6d00e9u,0x666500eau,0x757400ebu,0x737200ecu,0x7a7900edu,0x10000eeu,0x8000000fu,0x767500f0u,0x717000f1u,0x10000f2u,0x80000010u,0x6a6900f4u,0x686700f5u,0x696800f6u,0x757400f7u,0x10000f8u,0x80000011u,0x626100fbu,0x75730105u,0x686700fcu,0x666500fdu,0x535200feu,0x666500ffu,0x68670100u,0x6a690101u,0x706f0102u,0x6f6e0103u,0x1000104u,0x80000012u,0x75740107u,0x6665010du,0x62610108u,0x6f6e0109u,0x6463010au,0x6665010bu,0x100010cu,0x80000013u,0x7372010eu,0x7170010fu,0x76750110u,0x71700111u,0x6a690112u,0x6d6c0113u,0x6d6c0114u,0x62610115u,0x73720116u,0x7a790117u,0x45440118u,0x6a690119u,0x7473011au,0x7574011bu,0x6261011cu,0x6f6e011du,0x6463011eu,0x6665011fu,0x1000120u,0x80000014u,0x68670122u,0x69680123u,0x75740124u,0x1000125u,0x80000015u,0x75740127u,0x66650128u,0x73720129u,0x6a69012au,0x6261012bu,0x6d6c012cu,0x100012du,0x80000016u,0x6e6d0133u,0x0u,0x0u,0x0u,0x62610136u,0x66650134u,0x1000135u,0x80000017u,0x73720137u,0x1000138u,0x80000018u,0x6261013au,0x6463013bu,0x6a69013cu,0x7574013du,0x7a79013eu,0x100013fu,0x80000019u,0x74730144u,0x0u,0x0u,0x6a69014bu,0x6a690145u,0x75740146u,0x6a690147u,0x706f0148u,0x6f6e0149u,0x100014au,0x8000001au,0x6e6d014cu,0x6a69014du,0x7574014eu,0x6a69014fu,0x77760150u,0x66650151u,0x2f2e0152u,0x6a610153u,0x7574015cu,0x0u,0x706f016cu,0x0u,0x0u,0x0u,0x0u,0x0u,0x6f640171u,0x7574015du,0x7372015eu,0x6a69015fu,0x63620160u,0x76750161u,0x75740162u,0x66650163u,0x34300164u,0x1000168u,0x1000169u,0x100016au,0x100016bu,0x8000001bu,0x8000001cu,0x8000001du,0x8000001eu,0x6d6c016du,0x706f016eu,0x7372016fu,0x1000170u,0x8000001fu,0x100017cu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6564017du,0x80000020u,0x6665017eu,0x7978017fu,0x1000180u,0x80000021u,0x65640186u,0x0u,0x0u,0x0u,0x6f6e018bu,0x6a690187u,0x76750188u,0x74730189u,0x100018au,0x80000022u,0x6564018cu,0x6665018du,0x7372018eu,0x6665018fu,0x73720190u,0x1000191u,0x80000023u,0x7b7a019fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x666101a2u,0x73720218u,0x666501a0u,0x10001a1u,0x80000024u,0x757401a7u,0x0u,0x0u,0x0u,0x73720210u,0x767501a8u,0x747301a9u,0x444301aau,0x626101abu,0x6d6c01acu,0x6d6c01adu,0x636201aeu,0x626101afu,0x646301b0u,0x6c6b01b1u,0x560001b2u,0x80000025u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x74730208u,0x66650209u,0x7372020au,0x4544020bu,0x6261020cu,0x7574020du,0x6261020eu,0x100020fu,0x80000026u,0x66650211u,0x706f0212u,0x4e4d0213u,0x706f0214u,0x65640215u,0x66650216u,0x1000217u,0x80000027u,0x67660219u,0x6261021au,0x6463021bu,0x6665021cu,0x100021du,0x80000028u,0x6261021fu,0x6f6e0220u,0x74730221u,0x67660222u,0x706f0223u,0x73720224u,0x6e6d0225u,0x1000226u,0x80000029u,0x1000228u,0x8000002au,0x73720234u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6d6c027du,0x75740235u,0x66650236u,0x79780237u,0x2f2e0238u,0x75610239u,0x7574024du,0x0u,0x706f025du,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f0262u,0x0u,0x706f0268u,0x0u,0x62610270u,0x0u,0x62610276u,0x7574024eu,0x7372024fu,0x6a690250u,0x63620251u,0x76750252u,0x75740253u,0x66650254u,0x34300255u,0x1000259u,0x100025au,0x100025bu,0x100025cu,0x8000002bu,0x8000002cu,0x8000002du,0x8000002eu,0x6d6c025eu,0x706f025fu,0x73720260u,0x1000261u,0x8000002fu,0x73720263u,0x6e6d0264u,0x62610265u,0x6d6c0266u,0x1000267u,0x80000030u,0x74730269u,0x6a69026au,0x7574026bu,0x6a69026cu,0x706f026du,0x6f6e026eu,0x100026fu,0x80000031u,0x65640271u,0x6a690272u,0x76750273u,0x74730274u,0x1000275u,0x80000032u,0x6f6e0277u,0x68670278u,0x66650279u,0x6f6e027au,0x7574027bu,0x100027cu,0x80000033u,0x7675027eu,0x6e6d027fu,0x66650280u,0x1000281u,0x80000034u,0x73720283u,0x6d6c0284u,0x65640285u,0x1000286u,0x80000035u};
   uint32_t cur = 0x78610000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = (uint32_t)str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
static int info_hash(const char *str) {
   static const uint32_t table[] = {0x69680014u,0x6665001bu,0x6d6c0038u,0x66650043u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6a61004au,0x0u,0x0u,0x6261005fu,0x0u,0x66650068u,0x706f0070u,0x0u,0x0u,0x6261007du,0x62610015u,0x6f6e0016u,0x6f6e0017u,0x66650018u,0x6d6c0019u,0x100001au,0x8000000au,0x7466001cu,0x6261002au,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6463002fu,0x7675002bu,0x6d6c002cu,0x7574002du,0x100002eu,0x80000001u,0x73720030u,0x6a690031u,0x71700032u,0x75740033u,0x6a690034u,0x706f0035u,0x6f6e0036u,0x1000037u,0x80000004u,0x66650039u,0x6e6d003au,0x6665003bu,0x6f6e003cu,0x7574003du,0x5554003eu,0x7a79003fu,0x71700040u,0x66650041u,0x1000042u,0x80000005u,0x62610044u,0x75740045u,0x76750046u,0x73720047u,0x66650048u,0x1000049u,0x80000008u,0x79780053u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x6f6e0059u,0x6a690054u,0x6e6d0055u,0x76750056u,0x6e6d0057u,0x1000058u,0x80000003u,0x6a69005au,0x6e6d005bu,0x7675005cu,0x6e6d005du,0x100005eu,0x80000002u,0x73720060u,0x62610061u,0x6e6d0062u,0x66650063u,0x75740064u,0x66650065u,0x73720066u,0x1000067u,0x80000009u,0x72710069u,0x7675006au,0x6a69006bu,0x7372006cu,0x6665006du,0x6564006eu,0x100006fu,0x80000000u,0x76750071u,0x73720072u,0x64630073u,0x66650074u,0x47460075u,0x66650076u,0x62610077u,0x75740078u,0x76750079u,0x7372007au,0x6665007bu,0x100007cu,0x80000007u,0x6d6c007eu,0x7675007fu,0x66650080u,0x1000081u,0x80000006u};
   uint32_t cur = 0x77630000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = (uint32_t)str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
static const int32_t anari_true = 1;
static const int32_t anari_false = 0;
const char ** query_extensions() {
   static const char *extensions[] = {
      "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
      "ANARI_KHR_CAMERA_PERSPECTIVE",
      "ANARI_KHR_GEOMETRY_SPHERE",
      "ANARI_KHR_GEOMETRY_TRIANGLE",
      "ANARI_KHR_MATERIAL_MATTE",
      0
   };
   return extensions;
}
const char ** query_object_types(ANARIDataType type) {
   switch(type) {
      case ANARI_RENDERER:
      {
         static const char *ANARI_RENDERER_subtypes[] = {"default", 0};
         return ANARI_RENDERER_subtypes;
      }
      case ANARI_CAMERA:
      {
         static const char *ANARI_CAMERA_subtypes[] = {"orthographic", "perspective", 0};
         return ANARI_CAMERA_subtypes;
      }
      case ANARI_GEOMETRY:
      {
         static const char *ANARI_GEOMETRY_subtypes[] = {"sphere", "triangle", 0};
         return ANARI_GEOMETRY_subtypes;
      }
      case ANARI_MATERIAL:
      {
         static const char *ANARI_MATERIAL_subtypes[] = {"matte", 0};
         return ANARI_MATERIAL_subtypes;
      }
      default:
      {
         static const char *none_subtypes[] = {0};
         return none_subtypes;
      }
   }
}
static const void * ANARI_RENDERER_default_background_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC4 && infoType == ANARI_FLOAT32_VEC4) {
            static const float default_value[4] = {0.000000f, 0.000000f, 0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "background color and alpha (RGBA)";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_default_ambientColor_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {1.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "ambient light color (RGB)";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_default_ambientRadiance_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "ambient light intensity";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_default_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_RENDERER_default_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 6:
         return ANARI_RENDERER_default_background_info(paramType, infoName, infoType);
      case 2:
         return ANARI_RENDERER_default_ambientColor_info(paramType, infoName, infoType);
      case 3:
         return ANARI_RENDERER_default_ambientRadiance_info(paramType, infoName, infoType);
      case 23:
         return ANARI_RENDERER_default_name_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_DEVICE_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_DEVICE_statusCallback_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "callback used to report information to the application";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_DEVICE_statusCallbackUserData_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional pointer passed as the first argument of the status callback";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_DEVICE_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 23:
         return ANARI_DEVICE_name_info(paramType, infoName, infoType);
      case 37:
         return ANARI_DEVICE_statusCallback_info(paramType, infoName, infoType);
      case 38:
         return ANARI_DEVICE_statusCallbackUserData_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_ARRAY1D_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_ARRAY1D_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 23:
         return ANARI_ARRAY1D_name_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_ARRAY2D_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_ARRAY2D_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 23:
         return ANARI_ARRAY2D_name_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_ARRAY3D_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_ARRAY3D_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 23:
         return ANARI_ARRAY3D_name_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_FRAME_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_world_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "world to be rendererd";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_renderer_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "renderer which renders the frame";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_camera_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "camera used to render the world";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_size_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "size of the frame in pixels (width, height)";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_channel_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "enables mapping the color channel as the type specified";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_DATA_TYPE && infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8_VEC4, ANARI_UFIXED8_RGBA_SRGB, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_channel_depth_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "enables mapping the color channel as the type specified";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_DATA_TYPE && infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 23:
         return ANARI_FRAME_name_info(paramType, infoName, infoType);
      case 53:
         return ANARI_FRAME_world_info(paramType, infoName, infoType);
      case 35:
         return ANARI_FRAME_renderer_info(paramType, infoName, infoType);
      case 7:
         return ANARI_FRAME_camera_info(paramType, infoName, infoType);
      case 36:
         return ANARI_FRAME_size_info(paramType, infoName, infoType);
      case 8:
         return ANARI_FRAME_channel_color_info(paramType, infoName, infoType);
      case 9:
         return ANARI_FRAME_channel_depth_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GROUP_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GROUP_surface_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array of surface objects";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_SURFACE, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GROUP_volume_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array of volume objects";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_VOLUME, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GROUP_light_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array of light objects";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_LIGHT, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GROUP_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 23:
         return ANARI_GROUP_name_info(paramType, infoName, infoType);
      case 40:
         return ANARI_GROUP_surface_info(paramType, infoName, infoType);
      case 52:
         return ANARI_GROUP_volume_info(paramType, infoName, infoType);
      case 21:
         return ANARI_GROUP_light_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_INSTANCE_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_INSTANCE_transform_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
            static const float default_value[16] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "transform applied to objects in the instance";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_INSTANCE_group_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "group object being instanced";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_INSTANCE_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 23:
         return ANARI_INSTANCE_name_info(paramType, infoName, infoType);
      case 41:
         return ANARI_INSTANCE_transform_info(paramType, infoName, infoType);
      case 16:
         return ANARI_INSTANCE_group_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_WORLD_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_WORLD_instance_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array of instance objects in the world";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_INSTANCE, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_WORLD_surface_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array of non-instanced surface objects in the world";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_SURFACE, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_WORLD_volume_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array of non-instanced volume objects in the world";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_LIGHT, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_WORLD_light_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "array of non-instanced light objects in the world";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_LIGHT, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_WORLD_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 23:
         return ANARI_WORLD_name_info(paramType, infoName, infoType);
      case 19:
         return ANARI_WORLD_instance_info(paramType, infoName, infoType);
      case 40:
         return ANARI_WORLD_surface_info(paramType, infoName, infoType);
      case 52:
         return ANARI_WORLD_volume_info(paramType, infoName, infoType);
      case 21:
         return ANARI_WORLD_light_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_SURFACE_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SURFACE_geometry_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "geometry object defining the surface geometry";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SURFACE_material_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "material object defining the surface appearance";
            return description;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SURFACE_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 23:
         return ANARI_SURFACE_name_info(paramType, infoName, infoType);
      case 15:
         return ANARI_SURFACE_geometry_info(paramType, infoName, infoType);
      case 22:
         return ANARI_SURFACE_material_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "camera position";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_direction_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, -1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "main viewing direction";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_up_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 1.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "camera up direction";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_transform_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
            static const float default_value[16] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "camera transform";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_imageRegion_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_BOX2 && infoType == ANARI_FLOAT32_BOX2) {
            static const float default_value[4] = {0.000000f, 0.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "region mapped to the frame";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_apertureRadius_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "aperture radius";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_focusDistance_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "focus distance";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_stereoMode_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "none";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "stereo mode";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"none", "left", "right", "sideBySide", "topBottom", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_interpupillaryDistance_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.063500f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "interpupillary distance for stereo rendering";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_height_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "height of image plane";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_aspect_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "aspect ratio";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_near_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "near plane clip distance";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_far_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "far plane clip distance";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 0;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 23:
         return ANARI_CAMERA_orthographic_name_info(paramType, infoName, infoType);
      case 26:
         return ANARI_CAMERA_orthographic_position_info(paramType, infoName, infoType);
      case 11:
         return ANARI_CAMERA_orthographic_direction_info(paramType, infoName, infoType);
      case 42:
         return ANARI_CAMERA_orthographic_up_info(paramType, infoName, infoType);
      case 41:
         return ANARI_CAMERA_orthographic_transform_info(paramType, infoName, infoType);
      case 18:
         return ANARI_CAMERA_orthographic_imageRegion_info(paramType, infoName, infoType);
      case 4:
         return ANARI_CAMERA_orthographic_apertureRadius_info(paramType, infoName, infoType);
      case 13:
         return ANARI_CAMERA_orthographic_focusDistance_info(paramType, infoName, infoType);
      case 39:
         return ANARI_CAMERA_orthographic_stereoMode_info(paramType, infoName, infoType);
      case 20:
         return ANARI_CAMERA_orthographic_interpupillaryDistance_info(paramType, infoName, infoType);
      case 17:
         return ANARI_CAMERA_orthographic_height_info(paramType, infoName, infoType);
      case 5:
         return ANARI_CAMERA_orthographic_aspect_info(paramType, infoName, infoType);
      case 24:
         return ANARI_CAMERA_orthographic_near_info(paramType, infoName, infoType);
      case 12:
         return ANARI_CAMERA_orthographic_far_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_PERSPECTIVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "camera position";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_PERSPECTIVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_direction_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 0.000000f, -1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "main viewing direction";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_PERSPECTIVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_up_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.000000f, 1.000000f, 0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "camera up direction";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_PERSPECTIVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_transform_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_MAT4 && infoType == ANARI_FLOAT32_MAT4) {
            static const float default_value[16] = {1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f, 0.000000f, 0.000000f, 0.000000f, 0.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "camera transform";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_PERSPECTIVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_imageRegion_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_BOX2 && infoType == ANARI_FLOAT32_BOX2) {
            static const float default_value[4] = {0.000000f, 0.000000f, 1.000000f, 1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "region mapped to the frame";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_PERSPECTIVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_apertureRadius_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "aperture radius";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_PERSPECTIVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_focusDistance_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "focus distance";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_PERSPECTIVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_stereoMode_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "none";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "stereo mode";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"none", "left", "right", "sideBySide", "topBottom", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_PERSPECTIVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_interpupillaryDistance_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.063500f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "interpupillary distance for stereo rendering";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_PERSPECTIVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_fovy_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.047198f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertical field of view in radians";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_PERSPECTIVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_aspect_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "aspect ratio";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_PERSPECTIVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_near_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "near plane clip distance";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_PERSPECTIVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_far_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "far plane clip distance";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_PERSPECTIVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 1;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 23:
         return ANARI_CAMERA_perspective_name_info(paramType, infoName, infoType);
      case 26:
         return ANARI_CAMERA_perspective_position_info(paramType, infoName, infoType);
      case 11:
         return ANARI_CAMERA_perspective_direction_info(paramType, infoName, infoType);
      case 42:
         return ANARI_CAMERA_perspective_up_info(paramType, infoName, infoType);
      case 41:
         return ANARI_CAMERA_perspective_transform_info(paramType, infoName, infoType);
      case 18:
         return ANARI_CAMERA_perspective_imageRegion_info(paramType, infoName, infoType);
      case 4:
         return ANARI_CAMERA_perspective_apertureRadius_info(paramType, infoName, infoType);
      case 13:
         return ANARI_CAMERA_perspective_focusDistance_info(paramType, infoName, infoType);
      case 39:
         return ANARI_CAMERA_perspective_stereoMode_info(paramType, infoName, infoType);
      case 20:
         return ANARI_CAMERA_perspective_interpupillaryDistance_info(paramType, infoName, infoType);
      case 14:
         return ANARI_CAMERA_perspective_fovy_info(paramType, infoName, infoType);
      case 5:
         return ANARI_CAMERA_perspective_aspect_info(paramType, infoName, infoType);
      case 24:
         return ANARI_CAMERA_perspective_near_info(paramType, infoName, infoType);
      case 12:
         return ANARI_CAMERA_perspective_far_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_SPHERE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_primitive_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_SPHERE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_primitive_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_SPHERE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_primitive_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_SPHERE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_primitive_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_SPHERE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_primitive_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_SPHERE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_primitive_id_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "primitive id";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_SPHERE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_vertex_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "sphere position";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_SPHERE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_vertex_radius_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "sphere radius";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_SPHERE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_vertex_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_SPHERE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_vertex_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_SPHERE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_vertex_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_SPHERE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_vertex_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_SPHERE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_vertex_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_SPHERE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_primitive_index_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "index array";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_SPHERE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_radius_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "global sphere radius";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_SPHERE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 2;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 23:
         return ANARI_GEOMETRY_sphere_name_info(paramType, infoName, infoType);
      case 31:
         return ANARI_GEOMETRY_sphere_primitive_color_info(paramType, infoName, infoType);
      case 27:
         return ANARI_GEOMETRY_sphere_primitive_attribute0_info(paramType, infoName, infoType);
      case 28:
         return ANARI_GEOMETRY_sphere_primitive_attribute1_info(paramType, infoName, infoType);
      case 29:
         return ANARI_GEOMETRY_sphere_primitive_attribute2_info(paramType, infoName, infoType);
      case 30:
         return ANARI_GEOMETRY_sphere_primitive_attribute3_info(paramType, infoName, infoType);
      case 32:
         return ANARI_GEOMETRY_sphere_primitive_id_info(paramType, infoName, infoType);
      case 49:
         return ANARI_GEOMETRY_sphere_vertex_position_info(paramType, infoName, infoType);
      case 50:
         return ANARI_GEOMETRY_sphere_vertex_radius_info(paramType, infoName, infoType);
      case 47:
         return ANARI_GEOMETRY_sphere_vertex_color_info(paramType, infoName, infoType);
      case 43:
         return ANARI_GEOMETRY_sphere_vertex_attribute0_info(paramType, infoName, infoType);
      case 44:
         return ANARI_GEOMETRY_sphere_vertex_attribute1_info(paramType, infoName, infoType);
      case 45:
         return ANARI_GEOMETRY_sphere_vertex_attribute2_info(paramType, infoName, infoType);
      case 46:
         return ANARI_GEOMETRY_sphere_vertex_attribute3_info(paramType, infoName, infoType);
      case 33:
         return ANARI_GEOMETRY_sphere_primitive_index_info(paramType, infoName, infoType);
      case 34:
         return ANARI_GEOMETRY_sphere_radius_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_TRIANGLE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_primitive_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_TRIANGLE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_primitive_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_TRIANGLE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_primitive_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_TRIANGLE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_primitive_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_TRIANGLE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_primitive_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "per primitive attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_TRIANGLE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_primitive_id_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "primitive id";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32, ANARI_UINT64, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_TRIANGLE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_position_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_true;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex position";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_TRIANGLE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_normal_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex normal";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_FIXED16_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_TRIANGLE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_tangent_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex normal";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32_VEC3, ANARI_FIXED16_VEC3, ANARI_FLOAT32_VEC4, ANARI_FIXED16_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_TRIANGLE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex color";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UFIXED8, ANARI_UFIXED8_VEC2, ANARI_UFIXED8_VEC3, ANARI_UFIXED8_VEC4, ANARI_UFIXED8_R_SRGB, ANARI_UFIXED8_RA_SRGB, ANARI_UFIXED8_RGB_SRGB, ANARI_UFIXED8_RGBA_SRGB, ANARI_UFIXED16, ANARI_UFIXED16_VEC2, ANARI_UFIXED16_VEC3, ANARI_UFIXED16_VEC4, ANARI_UFIXED32, ANARI_UFIXED32_VEC2, ANARI_UFIXED32_VEC3, ANARI_UFIXED32_VEC4, ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_TRIANGLE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_attribute0_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute0";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_TRIANGLE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_attribute1_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute1";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_TRIANGLE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_attribute2_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute2";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_TRIANGLE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_vertex_attribute3_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "vertex attribute3";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_FLOAT32, ANARI_FLOAT32_VEC2, ANARI_FLOAT32_VEC3, ANARI_FLOAT32_VEC4, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_TRIANGLE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_primitive_index_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "index array";
            return description;
         }
      case 5: // elementType
         if(infoType == ANARI_DATA_TYPE_LIST) {
            static const ANARIDataType values[] = {ANARI_UINT32_VEC3, ANARI_UINT64_VEC3, ANARI_UNKNOWN};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_TRIANGLE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 3;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 23:
         return ANARI_GEOMETRY_triangle_name_info(paramType, infoName, infoType);
      case 31:
         return ANARI_GEOMETRY_triangle_primitive_color_info(paramType, infoName, infoType);
      case 27:
         return ANARI_GEOMETRY_triangle_primitive_attribute0_info(paramType, infoName, infoType);
      case 28:
         return ANARI_GEOMETRY_triangle_primitive_attribute1_info(paramType, infoName, infoType);
      case 29:
         return ANARI_GEOMETRY_triangle_primitive_attribute2_info(paramType, infoName, infoType);
      case 30:
         return ANARI_GEOMETRY_triangle_primitive_attribute3_info(paramType, infoName, infoType);
      case 32:
         return ANARI_GEOMETRY_triangle_primitive_id_info(paramType, infoName, infoType);
      case 49:
         return ANARI_GEOMETRY_triangle_vertex_position_info(paramType, infoName, infoType);
      case 48:
         return ANARI_GEOMETRY_triangle_vertex_normal_info(paramType, infoName, infoType);
      case 51:
         return ANARI_GEOMETRY_triangle_vertex_tangent_info(paramType, infoName, infoType);
      case 47:
         return ANARI_GEOMETRY_triangle_vertex_color_info(paramType, infoName, infoType);
      case 43:
         return ANARI_GEOMETRY_triangle_vertex_attribute0_info(paramType, infoName, infoType);
      case 44:
         return ANARI_GEOMETRY_triangle_vertex_attribute1_info(paramType, infoName, infoType);
      case 45:
         return ANARI_GEOMETRY_triangle_vertex_attribute2_info(paramType, infoName, infoType);
      case 46:
         return ANARI_GEOMETRY_triangle_vertex_attribute3_info(paramType, infoName, infoType);
      case 33:
         return ANARI_GEOMETRY_triangle_primitive_index_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_MATERIAL_matte_name_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "optional object name";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_MATERIAL_MATTE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_matte_color_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32_VEC3 && infoType == ANARI_FLOAT32_VEC3) {
            static const float default_value[3] = {0.800000f, 0.800000f, 0.800000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "diffuse color";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"color", "worldPosition", "worldNormal", "objectPosition", "objectNormal", "attribute0", "attribute1", "attribute2", "attribute3", "primitiveId", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_MATERIAL_MATTE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_matte_opacity_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {1.000000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "opacity";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"color", "worldPosition", "worldNormal", "objectPosition", "objectNormal", "attribute0", "attribute1", "attribute2", "attribute3", "primitiveId", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_MATERIAL_MATTE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_matte_alphaMode_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_STRING && infoType == ANARI_STRING) {
            static const char *default_value = "opaque";
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "alpha mode";
            return description;
         }
      case 6: // value
         if(paramType == ANARI_STRING && infoType == ANARI_STRING_LIST) {
            static const char *values[] = {"opaque", "blend", "mask", nullptr};
            return values;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_MATERIAL_MATTE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_matte_alphaCutoff_info(ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   (void)paramType;
   switch(infoName) {
      case 0: // required
         if(infoType == ANARI_BOOL) {
            return &anari_false;
         } else {
            return nullptr;
         }
      case 1: // default
         if(paramType == ANARI_FLOAT32 && infoType == ANARI_FLOAT32) {
            static const float default_value[1] = {0.500000f};
            return default_value;
         } else {
            return nullptr;
         }
      case 4: // description
         {
            static const char *description = "cutoff for alpha mask mode";
            return description;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_MATERIAL_MATTE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int32_t value = 4;
            return &value;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_matte_param_info(const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(param_hash(paramName)) {
      case 23:
         return ANARI_MATERIAL_matte_name_info(paramType, infoName, infoType);
      case 10:
         return ANARI_MATERIAL_matte_color_info(paramType, infoName, infoType);
      case 25:
         return ANARI_MATERIAL_matte_opacity_info(paramType, infoName, infoType);
      case 1:
         return ANARI_MATERIAL_matte_alphaMode_info(paramType, infoName, infoType);
      case 0:
         return ANARI_MATERIAL_matte_alphaCutoff_info(paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_CAMERA_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 2:
         return ANARI_CAMERA_orthographic_param_info(paramName, paramType, infoName, infoType);
      case 3:
         return ANARI_CAMERA_perspective_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GEOMETRY_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 4:
         return ANARI_GEOMETRY_sphere_param_info(paramName, paramType, infoName, infoType);
      case 5:
         return ANARI_GEOMETRY_triangle_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_MATERIAL_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 1:
         return ANARI_MATERIAL_matte_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_RENDERER_param_info(const char *subtype, const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 0:
         return ANARI_RENDERER_default_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
const void * query_param_info_enum(ANARIDataType type, const char *subtype, const char *paramName, ANARIDataType paramType, int infoName, ANARIDataType infoType) {
   switch(type) {
      case ANARI_CAMERA:
         return ANARI_CAMERA_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_GEOMETRY:
         return ANARI_GEOMETRY_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_MATERIAL:
         return ANARI_MATERIAL_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_RENDERER:
         return ANARI_RENDERER_param_info(subtype, paramName, paramType, infoName, infoType);
      case ANARI_DEVICE:
         return ANARI_DEVICE_param_info(paramName, paramType, infoName, infoType);
      case ANARI_ARRAY1D:
         return ANARI_ARRAY1D_param_info(paramName, paramType, infoName, infoType);
      case ANARI_ARRAY2D:
         return ANARI_ARRAY2D_param_info(paramName, paramType, infoName, infoType);
      case ANARI_ARRAY3D:
         return ANARI_ARRAY3D_param_info(paramName, paramType, infoName, infoType);
      case ANARI_FRAME:
         return ANARI_FRAME_param_info(paramName, paramType, infoName, infoType);
      case ANARI_GROUP:
         return ANARI_GROUP_param_info(paramName, paramType, infoName, infoType);
      case ANARI_INSTANCE:
         return ANARI_INSTANCE_param_info(paramName, paramType, infoName, infoType);
      case ANARI_WORLD:
         return ANARI_WORLD_param_info(paramName, paramType, infoName, infoType);
      case ANARI_SURFACE:
         return ANARI_SURFACE_param_info(paramName, paramType, infoName, infoType);
      default:
         return nullptr;
   }
}
const void * query_param_info(ANARIDataType type, const char *subtype, const char *paramName, ANARIDataType paramType, const char *infoNameString, ANARIDataType infoType) {
   int infoName = info_hash(infoNameString);
   return query_param_info_enum(type, subtype, paramName, paramType, infoName, infoType);
}
static const void * ANARI_RENDERER_default_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "default renderer";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"background", ANARI_FLOAT32_VEC4},
               {"ambientColor", ANARI_FLOAT32_VEC3},
               {"ambientRadiance", ANARI_FLOAT32},
               {"name", ANARI_STRING},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 8: // feature
         if(infoType == ANARI_STRING_LIST) {
            static const char *extensions[] = {
               "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
               "ANARI_KHR_CAMERA_PERSPECTIVE",
               "ANARI_KHR_GEOMETRY_SPHERE",
               "ANARI_KHR_GEOMETRY_TRIANGLE",
               "ANARI_KHR_MATERIAL_MATTE",
               0
            };
            return extensions;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_DEVICE_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "device object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"statusCallback", ANARI_STATUS_CALLBACK},
               {"statusCallbackUserData", ANARI_VOID_POINTER},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 8: // feature
         if(infoType == ANARI_STRING_LIST) {
            static const char *extensions[] = {
               "ANARI_KHR_CAMERA_ORTHOGRAPHIC",
               "ANARI_KHR_CAMERA_PERSPECTIVE",
               "ANARI_KHR_GEOMETRY_SPHERE",
               "ANARI_KHR_GEOMETRY_TRIANGLE",
               "ANARI_KHR_MATERIAL_MATTE",
               0
            };
            return extensions;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_ARRAY1D_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "one dimensional array object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_ARRAY2D_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "two dimensional array object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_ARRAY3D_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "three dimensional array object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_FRAME_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "frame object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"world", ANARI_WORLD},
               {"renderer", ANARI_RENDERER},
               {"camera", ANARI_CAMERA},
               {"size", ANARI_UINT32_VEC2},
               {"channel.color", ANARI_DATA_TYPE},
               {"channel.depth", ANARI_DATA_TYPE},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 10: // channel
         if(infoType == ANARI_STRING_LIST) {
            static const char *channel[] = {
               "channel.color",
               "channel.depth",
               0
            };
            return channel;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GROUP_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "group object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"surface", ANARI_ARRAY1D},
               {"volume", ANARI_ARRAY1D},
               {"light", ANARI_ARRAY1D},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_INSTANCE_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "instance object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"transform", ANARI_FLOAT32_MAT4},
               {"group", ANARI_GROUP},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_WORLD_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "world object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"instance", ANARI_ARRAY1D},
               {"surface", ANARI_ARRAY1D},
               {"volume", ANARI_ARRAY1D},
               {"light", ANARI_ARRAY1D},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_SURFACE_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "surface object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"geometry", ANARI_GEOMETRY},
               {"material", ANARI_MATERIAL},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_orthographic_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "orthographic camera object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"position", ANARI_FLOAT32_VEC3},
               {"direction", ANARI_FLOAT32_VEC3},
               {"up", ANARI_FLOAT32_VEC3},
               {"transform", ANARI_FLOAT32_MAT4},
               {"imageRegion", ANARI_FLOAT32_BOX2},
               {"apertureRadius", ANARI_FLOAT32},
               {"focusDistance", ANARI_FLOAT32},
               {"stereoMode", ANARI_STRING},
               {"interpupillaryDistance", ANARI_FLOAT32},
               {"height", ANARI_FLOAT32},
               {"aspect", ANARI_FLOAT32},
               {"near", ANARI_FLOAT32},
               {"far", ANARI_FLOAT32},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_ORTHOGRAPHIC";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 0;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_perspective_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "perspective camera object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"position", ANARI_FLOAT32_VEC3},
               {"direction", ANARI_FLOAT32_VEC3},
               {"up", ANARI_FLOAT32_VEC3},
               {"transform", ANARI_FLOAT32_MAT4},
               {"imageRegion", ANARI_FLOAT32_BOX2},
               {"apertureRadius", ANARI_FLOAT32},
               {"focusDistance", ANARI_FLOAT32},
               {"stereoMode", ANARI_STRING},
               {"interpupillaryDistance", ANARI_FLOAT32},
               {"fovy", ANARI_FLOAT32},
               {"aspect", ANARI_FLOAT32},
               {"near", ANARI_FLOAT32},
               {"far", ANARI_FLOAT32},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_CAMERA_PERSPECTIVE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 1;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_sphere_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "sphere geometry object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"primitive.color", ANARI_ARRAY1D},
               {"primitive.attribute0", ANARI_ARRAY1D},
               {"primitive.attribute1", ANARI_ARRAY1D},
               {"primitive.attribute2", ANARI_ARRAY1D},
               {"primitive.attribute3", ANARI_ARRAY1D},
               {"primitive.id", ANARI_ARRAY1D},
               {"vertex.position", ANARI_ARRAY1D},
               {"vertex.radius", ANARI_ARRAY1D},
               {"vertex.color", ANARI_ARRAY1D},
               {"vertex.attribute0", ANARI_ARRAY1D},
               {"vertex.attribute1", ANARI_ARRAY1D},
               {"vertex.attribute2", ANARI_ARRAY1D},
               {"vertex.attribute3", ANARI_ARRAY1D},
               {"primitive.index", ANARI_ARRAY1D},
               {"radius", ANARI_FLOAT32},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_SPHERE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 2;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_GEOMETRY_triangle_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "triangle geometry object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"primitive.color", ANARI_ARRAY1D},
               {"primitive.attribute0", ANARI_ARRAY1D},
               {"primitive.attribute1", ANARI_ARRAY1D},
               {"primitive.attribute2", ANARI_ARRAY1D},
               {"primitive.attribute3", ANARI_ARRAY1D},
               {"primitive.id", ANARI_ARRAY1D},
               {"vertex.position", ANARI_ARRAY1D},
               {"vertex.normal", ANARI_ARRAY1D},
               {"vertex.tangent", ANARI_ARRAY1D},
               {"vertex.color", ANARI_ARRAY1D},
               {"vertex.attribute0", ANARI_ARRAY1D},
               {"vertex.attribute1", ANARI_ARRAY1D},
               {"vertex.attribute2", ANARI_ARRAY1D},
               {"vertex.attribute3", ANARI_ARRAY1D},
               {"primitive.index", ANARI_ARRAY1D},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_GEOMETRY_TRIANGLE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 3;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_MATERIAL_matte_info(int infoName, ANARIDataType infoType) {
   switch(infoName) {
      case 4: // description
         {
            static const char *description = "matte material object";
            return description;
         }
      case 9: // parameter
         if(infoType == ANARI_PARAMETER_LIST) {
            static const ANARIParameter parameters[] = {
               {"name", ANARI_STRING},
               {"color", ANARI_FLOAT32_VEC3},
               {"color", ANARI_SAMPLER},
               {"color", ANARI_STRING},
               {"opacity", ANARI_FLOAT32},
               {"opacity", ANARI_SAMPLER},
               {"opacity", ANARI_STRING},
               {"alphaMode", ANARI_STRING},
               {"alphaCutoff", ANARI_FLOAT32},
               {0, ANARI_UNKNOWN}
            };
            return parameters;
         } else {
            return nullptr;
         }
      case 7: // sourceFeature
         if(infoType == ANARI_STRING) {
            static const char *feature = "KHR_MATERIAL_MATTE";
            return feature;
         } else if(infoType == ANARI_INT32) {
            static const int value = 4;
            return &value;
         } else {
            return nullptr;
         }
      default: return nullptr;
   }
}
static const void * ANARI_CAMERA_info(const char *subtype, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 2:
         return ANARI_CAMERA_orthographic_info(infoName, infoType);
      case 3:
         return ANARI_CAMERA_perspective_info(infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_GEOMETRY_info(const char *subtype, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 4:
         return ANARI_GEOMETRY_sphere_info(infoName, infoType);
      case 5:
         return ANARI_GEOMETRY_triangle_info(infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_MATERIAL_info(const char *subtype, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 1:
         return ANARI_MATERIAL_matte_info(infoName, infoType);
      default:
         return nullptr;
   }
}
static const void * ANARI_RENDERER_info(const char *subtype, int infoName, ANARIDataType infoType) {
   switch(subtype_hash(subtype)) {
      case 0:
         return ANARI_RENDERER_default_info(infoName, infoType);
      default:
         return nullptr;
   }
}
const void * query_object_info_enum(ANARIDataType type, const char *subtype, int infoName, ANARIDataType infoType) {
   switch(type) {
      case ANARI_CAMERA:
         return ANARI_CAMERA_info(subtype, infoName, infoType);
      case ANARI_GEOMETRY:
         return ANARI_GEOMETRY_info(subtype, infoName, infoType);
      case ANARI_MATERIAL:
         return ANARI_MATERIAL_info(subtype, infoName, infoType);
      case ANARI_RENDERER:
         return ANARI_RENDERER_info(subtype, infoName, infoType);
      case ANARI_DEVICE:
         return ANARI_DEVICE_info(infoName, infoType);
      case ANARI_ARRAY1D:
         return ANARI_ARRAY1D_info(infoName, infoType);
      case ANARI_ARRAY2D:
         return ANARI_ARRAY2D_info(infoName, infoType);
      case ANARI_ARRAY3D:
         return ANARI_ARRAY3D_info(infoName, infoType);
      case ANARI_FRAME:
         return ANARI_FRAME_info(infoName, infoType);
      case ANARI_GROUP:
         return ANARI_GROUP_info(infoName, infoType);
      case ANARI_INSTANCE:
         return ANARI_INSTANCE_info(infoName, infoType);
      case ANARI_WORLD:
         return ANARI_WORLD_info(infoName, infoType);
      case ANARI_SURFACE:
         return ANARI_SURFACE_info(infoName, infoType);
      default:
         return nullptr;
   }
}
const void * query_object_info(ANARIDataType type, const char *subtype, const char *infoNameString, ANARIDataType infoType) {
   int infoName = info_hash(infoNameString);   return query_object_info_enum(type, subtype, infoName, infoType);}
}
