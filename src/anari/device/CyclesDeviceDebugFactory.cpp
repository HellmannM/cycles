// Copyright 2021 The Khronos Group
// SPDX-License-Identifier: Apache-2.0

// This file was generated by generate_debug_objects.py
// Don't make changes to this directly

#include "anari/ext/debug/DebugObject.h"
using namespace anari::debug_device;
namespace cycles {
class CyclesDeviceDebugFactory : public anari::debug_device::ObjectFactory {
public:
anari::debug_device::DebugObjectBase* new_camera(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) override;
anari::debug_device::DebugObjectBase* new_geometry(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) override;
anari::debug_device::DebugObjectBase* new_material(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) override;
anari::debug_device::DebugObjectBase* new_renderer(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) override;
   anari::debug_device::DebugObjectBase* new_device(anari::debug_device::DebugDevice *td, ANARIObject wh, ANARIObject h) override;
   anari::debug_device::DebugObjectBase* new_array1d(anari::debug_device::DebugDevice *td, ANARIObject wh, ANARIObject h) override;
   anari::debug_device::DebugObjectBase* new_array2d(anari::debug_device::DebugDevice *td, ANARIObject wh, ANARIObject h) override;
   anari::debug_device::DebugObjectBase* new_array3d(anari::debug_device::DebugDevice *td, ANARIObject wh, ANARIObject h) override;
   anari::debug_device::DebugObjectBase* new_frame(anari::debug_device::DebugDevice *td, ANARIObject wh, ANARIObject h) override;
   anari::debug_device::DebugObjectBase* new_group(anari::debug_device::DebugDevice *td, ANARIObject wh, ANARIObject h) override;
   anari::debug_device::DebugObjectBase* new_instance(anari::debug_device::DebugDevice *td, ANARIObject wh, ANARIObject h) override;
   anari::debug_device::DebugObjectBase* new_world(anari::debug_device::DebugDevice *td, ANARIObject wh, ANARIObject h) override;
   anari::debug_device::DebugObjectBase* new_surface(anari::debug_device::DebugDevice *td, ANARIObject wh, ANARIObject h) override;
   void print_summary(anari::debug_device::DebugDevice *td) override;
   void use_feature(int feature);
};
namespace {
class renderer_default : public DebugObject<ANARI_RENDERER> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x62610001u,0x6e6d0002u,0x66650003u,0x1000004u,0x80000000u};
      uint32_t cur = 0x6f6e0000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   renderer_default(DebugDevice *td, CyclesDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING,ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_RENDERER, "default", paramname, paramtype, name_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_RENDERER, "default", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "default";
   }
};
class device : public DebugObject<ANARI_DEVICE> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x62610006u,0x0u,0x0u,0x0u,0x0u,0x7574000au,0x6e6d0007u,0x66650008u,0x1000009u,0x80000000u,0x6261000bu,0x7574000cu,0x7675000du,0x7473000eu,0x4443000fu,0x62610010u,0x6d6c0011u,0x6d6c0012u,0x63620013u,0x62610014u,0x64630015u,0x6c6b0016u,0x56000017u,0x80000001u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7473006du,0x6665006eu,0x7372006fu,0x45440070u,0x62610071u,0x75740072u,0x62610073u,0x1000074u,0x80000002u};
      uint32_t cur = 0x746e0000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   device(DebugDevice *td, CyclesDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_DEVICE, "", paramname, paramtype, name_types);
            return;
         }
         case 1: { //statusCallback
            ANARIDataType statusCallback_types[] = {ANARI_STATUS_CALLBACK, ANARI_UNKNOWN};
            check_type(ANARI_DEVICE, "", paramname, paramtype, statusCallback_types);
            return;
         }
         case 2: { //statusCallbackUserData
            ANARIDataType statusCallbackUserData_types[] = {ANARI_VOID_POINTER, ANARI_UNKNOWN};
            check_type(ANARI_DEVICE, "", paramname, paramtype, statusCallbackUserData_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_DEVICE, "", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "";
   }
};
class array1d : public DebugObject<ANARI_ARRAY1D> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x62610001u,0x6e6d0002u,0x66650003u,0x1000004u,0x80000000u};
      uint32_t cur = 0x6f6e0000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   array1d(DebugDevice *td, CyclesDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_ARRAY1D, "", paramname, paramtype, name_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_ARRAY1D, "", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "";
   }
};
class array2d : public DebugObject<ANARI_ARRAY2D> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x62610001u,0x6e6d0002u,0x66650003u,0x1000004u,0x80000000u};
      uint32_t cur = 0x6f6e0000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   array2d(DebugDevice *td, CyclesDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_ARRAY2D, "", paramname, paramtype, name_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_ARRAY2D, "", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "";
   }
};
class array3d : public DebugObject<ANARI_ARRAY3D> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x62610001u,0x6e6d0002u,0x66650003u,0x1000004u,0x80000000u};
      uint32_t cur = 0x6f6e0000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   array3d(DebugDevice *td, CyclesDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_ARRAY3D, "", paramname, paramtype, name_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_ARRAY3D, "", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "";
   }
};
class frame : public DebugObject<ANARI_FRAME> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x69610015u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610034u,0x0u,0x0u,0x0u,0x66650038u,0x6a690040u,0x0u,0x0u,0x0u,0x706f0044u,0x6e6d001du,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610022u,0x6665001eu,0x7372001fu,0x62610020u,0x1000021u,0x80000003u,0x6f6e0023u,0x6f6e0024u,0x66650025u,0x6d6c0026u,0x2f2e0027u,0x65630028u,0x706f002au,0x6665002fu,0x6d6c002bu,0x706f002cu,0x7372002du,0x100002eu,0x80000005u,0x71700030u,0x75740031u,0x69680032u,0x1000033u,0x80000006u,0x6e6d0035u,0x66650036u,0x1000037u,0x80000000u,0x6f6e0039u,0x6564003au,0x6665003bu,0x7372003cu,0x6665003du,0x7372003eu,0x100003fu,0x80000002u,0x7b7a0041u,0x66650042u,0x1000043u,0x80000004u,0x73720045u,0x6d6c0046u,0x65640047u,0x1000048u,0x80000001u};
      uint32_t cur = 0x78630000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   frame(DebugDevice *td, CyclesDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_FRAME, "", paramname, paramtype, name_types);
            return;
         }
         case 1: { //world
            ANARIDataType world_types[] = {ANARI_WORLD, ANARI_UNKNOWN};
            check_type(ANARI_FRAME, "", paramname, paramtype, world_types);
            return;
         }
         case 2: { //renderer
            ANARIDataType renderer_types[] = {ANARI_RENDERER, ANARI_UNKNOWN};
            check_type(ANARI_FRAME, "", paramname, paramtype, renderer_types);
            return;
         }
         case 3: { //camera
            ANARIDataType camera_types[] = {ANARI_CAMERA, ANARI_UNKNOWN};
            check_type(ANARI_FRAME, "", paramname, paramtype, camera_types);
            return;
         }
         case 4: { //size
            ANARIDataType size_types[] = {ANARI_UINT32_VEC2, ANARI_UNKNOWN};
            check_type(ANARI_FRAME, "", paramname, paramtype, size_types);
            return;
         }
         case 5: { //channel.color
            ANARIDataType channel_color_types[] = {ANARI_DATA_TYPE, ANARI_UNKNOWN};
            check_type(ANARI_FRAME, "", paramname, paramtype, channel_color_types);
            return;
         }
         case 6: { //channel.depth
            ANARIDataType channel_depth_types[] = {ANARI_DATA_TYPE, ANARI_UNKNOWN};
            check_type(ANARI_FRAME, "", paramname, paramtype, channel_depth_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_FRAME, "", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "";
   }
};
class group : public DebugObject<ANARI_GROUP> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x6a69000bu,0x0u,0x62610010u,0x0u,0x0u,0x0u,0x0u,0x76750014u,0x0u,0x0u,0x706f001bu,0x6867000cu,0x6968000du,0x7574000eu,0x100000fu,0x80000003u,0x6e6d0011u,0x66650012u,0x1000013u,0x80000000u,0x73720015u,0x67660016u,0x62610017u,0x64630018u,0x66650019u,0x100001au,0x80000001u,0x6d6c001cu,0x7675001du,0x6e6d001eu,0x6665001fu,0x1000020u,0x80000002u};
      uint32_t cur = 0x776c0000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   group(DebugDevice *td, CyclesDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_GROUP, "", paramname, paramtype, name_types);
            return;
         }
         case 1: { //surface
            ANARIDataType surface_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GROUP, "", paramname, paramtype, surface_types);
            return;
         }
         case 2: { //volume
            ANARIDataType volume_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GROUP, "", paramname, paramtype, volume_types);
            return;
         }
         case 3: { //light
            ANARIDataType light_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GROUP, "", paramname, paramtype, light_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_GROUP, "", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "";
   }
};
class instance : public DebugObject<ANARI_INSTANCE> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x7372000eu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610013u,0x0u,0x0u,0x0u,0x0u,0x0u,0x73720017u,0x706f000fu,0x76750010u,0x71700011u,0x1000012u,0x80000002u,0x6e6d0014u,0x66650015u,0x1000016u,0x80000000u,0x62610018u,0x6f6e0019u,0x7473001au,0x6766001bu,0x706f001cu,0x7372001du,0x6e6d001eu,0x100001fu,0x80000001u};
      uint32_t cur = 0x75670000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   instance(DebugDevice *td, CyclesDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_INSTANCE, "", paramname, paramtype, name_types);
            return;
         }
         case 1: { //transform
            ANARIDataType transform_types[] = {ANARI_FLOAT32_MAT4, ANARI_UNKNOWN};
            check_type(ANARI_INSTANCE, "", paramname, paramtype, transform_types);
            return;
         }
         case 2: { //group
            ANARIDataType group_types[] = {ANARI_GROUP, ANARI_UNKNOWN};
            check_type(ANARI_INSTANCE, "", paramname, paramtype, group_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_INSTANCE, "", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "";
   }
};
class world : public DebugObject<ANARI_WORLD> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x6f6e000eu,0x0u,0x0u,0x6a690016u,0x0u,0x6261001bu,0x0u,0x0u,0x0u,0x0u,0x7675001fu,0x0u,0x0u,0x706f0026u,0x7473000fu,0x75740010u,0x62610011u,0x6f6e0012u,0x64630013u,0x66650014u,0x1000015u,0x80000001u,0x68670017u,0x69680018u,0x75740019u,0x100001au,0x80000004u,0x6e6d001cu,0x6665001du,0x100001eu,0x80000000u,0x73720020u,0x67660021u,0x62610022u,0x64630023u,0x66650024u,0x1000025u,0x80000002u,0x6d6c0027u,0x76750028u,0x6e6d0029u,0x6665002au,0x100002bu,0x80000003u};
      uint32_t cur = 0x77690000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   world(DebugDevice *td, CyclesDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_WORLD, "", paramname, paramtype, name_types);
            return;
         }
         case 1: { //instance
            ANARIDataType instance_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_WORLD, "", paramname, paramtype, instance_types);
            return;
         }
         case 2: { //surface
            ANARIDataType surface_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_WORLD, "", paramname, paramtype, surface_types);
            return;
         }
         case 3: { //volume
            ANARIDataType volume_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_WORLD, "", paramname, paramtype, volume_types);
            return;
         }
         case 4: { //light
            ANARIDataType light_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_WORLD, "", paramname, paramtype, light_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_WORLD, "", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "";
   }
};
class surface : public DebugObject<ANARI_SURFACE> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x66650008u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610010u,0x62610018u,0x706f0009u,0x6e6d000au,0x6665000bu,0x7574000cu,0x7372000du,0x7a79000eu,0x100000fu,0x80000001u,0x75740011u,0x66650012u,0x73720013u,0x6a690014u,0x62610015u,0x6d6c0016u,0x1000017u,0x80000002u,0x6e6d0019u,0x6665001au,0x100001bu,0x80000000u};
      uint32_t cur = 0x6f670000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   surface(DebugDevice *td, CyclesDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_SURFACE, "", paramname, paramtype, name_types);
            return;
         }
         case 1: { //geometry
            ANARIDataType geometry_types[] = {ANARI_GEOMETRY, ANARI_UNKNOWN};
            check_type(ANARI_SURFACE, "", paramname, paramtype, geometry_types);
            return;
         }
         case 2: { //material
            ANARIDataType material_types[] = {ANARI_MATERIAL, ANARI_UNKNOWN};
            check_type(ANARI_SURFACE, "", paramname, paramtype, material_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_SURFACE, "", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "";
   }
};
class camera_orthographic : public DebugObject<ANARI_CAMERA> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x74700015u,0x0u,0x0u,0x6a69002bu,0x0u,0x706f0034u,0x0u,0x0u,0x6f6d0041u,0x0u,0x0u,0x0u,0x0u,0x62610062u,0x0u,0x706f0066u,0x0u,0x0u,0x7574006eu,0x73720078u,0x71700081u,0x66650019u,0x0u,0x0u,0x71700026u,0x7372001au,0x7574001bu,0x7675001cu,0x7372001du,0x6665001eu,0x5352001fu,0x62610020u,0x65640021u,0x6a690022u,0x76750023u,0x74730024u,0x1000025u,0x80000006u,0x66650027u,0x64630028u,0x75740029u,0x100002au,0x8000000au,0x7372002cu,0x6665002du,0x6463002eu,0x7574002fu,0x6a690030u,0x706f0031u,0x6f6e0032u,0x1000033u,0x80000002u,0x64630035u,0x76750036u,0x74730037u,0x45440038u,0x6a690039u,0x7473003au,0x7574003bu,0x6261003cu,0x6f6e003du,0x6463003eu,0x6665003fu,0x1000040u,0x80000007u,0x62610043u,0x7574004du,0x68670044u,0x66650045u,0x53520046u,0x66650047u,0x68670048u,0x6a690049u,0x706f004au,0x6f6e004bu,0x100004cu,0x80000005u,0x6665004eu,0x7372004fu,0x71700050u,0x76750051u,0x71700052u,0x6a690053u,0x6d6c0054u,0x6d6c0055u,0x62610056u,0x73720057u,0x7a790058u,0x45440059u,0x6a69005au,0x7473005bu,0x7574005cu,0x6261005du,0x6f6e005eu,0x6463005fu,0x66650060u,0x1000061u,0x80000009u,0x6e6d0063u,0x66650064u,0x1000065u,0x80000000u,0x74730067u,0x6a690068u,0x75740069u,0x6a69006au,0x706f006bu,0x6f6e006cu,0x100006du,0x80000001u,0x6665006fu,0x73720070u,0x66650071u,0x706f0072u,0x4e4d0073u,0x706f0074u,0x65640075u,0x66650076u,0x1000077u,0x80000008u,0x62610079u,0x6f6e007au,0x7473007bu,0x6766007cu,0x706f007du,0x7372007eu,0x6e6d007fu,0x1000080u,0x80000004u,0x1000082u,0x80000003u};
      uint32_t cur = 0x76610000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   camera_orthographic(DebugDevice *td, CyclesDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "orthographic", paramname, paramtype, name_types);
            return;
         }
         case 1: { //position
            ANARIDataType position_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "orthographic", paramname, paramtype, position_types);
            return;
         }
         case 2: { //direction
            ANARIDataType direction_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "orthographic", paramname, paramtype, direction_types);
            return;
         }
         case 3: { //up
            ANARIDataType up_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "orthographic", paramname, paramtype, up_types);
            return;
         }
         case 4: { //transform
            ANARIDataType transform_types[] = {ANARI_FLOAT32_MAT4, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "orthographic", paramname, paramtype, transform_types);
            return;
         }
         case 5: { //imageRegion
            ANARIDataType imageRegion_types[] = {ANARI_FLOAT32_BOX2, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "orthographic", paramname, paramtype, imageRegion_types);
            return;
         }
         case 6: { //apertureRadius
            ANARIDataType apertureRadius_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "orthographic", paramname, paramtype, apertureRadius_types);
            return;
         }
         case 7: { //focusDistance
            ANARIDataType focusDistance_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "orthographic", paramname, paramtype, focusDistance_types);
            return;
         }
         case 8: { //stereoMode
            ANARIDataType stereoMode_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "orthographic", paramname, paramtype, stereoMode_types);
            return;
         }
         case 9: { //interpupillaryDistance
            ANARIDataType interpupillaryDistance_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "orthographic", paramname, paramtype, interpupillaryDistance_types);
            return;
         }
         case 10: { //aspect
            ANARIDataType aspect_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "orthographic", paramname, paramtype, aspect_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_CAMERA, "orthographic", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "orthographic";
   }
};
class camera_perspective : public DebugObject<ANARI_CAMERA> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x74700015u,0x0u,0x0u,0x6a69002bu,0x0u,0x706f0034u,0x0u,0x0u,0x6f6d0056u,0x0u,0x0u,0x0u,0x0u,0x62610077u,0x0u,0x706f007bu,0x0u,0x0u,0x75740083u,0x7372008du,0x71700096u,0x66650019u,0x0u,0x0u,0x71700026u,0x7372001au,0x7574001bu,0x7675001cu,0x7372001du,0x6665001eu,0x5352001fu,0x62610020u,0x65640021u,0x6a690022u,0x76750023u,0x74730024u,0x1000025u,0x80000006u,0x66650027u,0x64630028u,0x75740029u,0x100002au,0x8000000bu,0x7372002cu,0x6665002du,0x6463002eu,0x7574002fu,0x6a690030u,0x706f0031u,0x6f6e0032u,0x1000033u,0x80000002u,0x77630035u,0x76750049u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7a790054u,0x7473004au,0x4544004bu,0x6a69004cu,0x7473004du,0x7574004eu,0x6261004fu,0x6f6e0050u,0x64630051u,0x66650052u,0x1000053u,0x80000007u,0x1000055u,0x8000000au,0x62610058u,0x75740062u,0x68670059u,0x6665005au,0x5352005bu,0x6665005cu,0x6867005du,0x6a69005eu,0x706f005fu,0x6f6e0060u,0x1000061u,0x80000005u,0x66650063u,0x73720064u,0x71700065u,0x76750066u,0x71700067u,0x6a690068u,0x6d6c0069u,0x6d6c006au,0x6261006bu,0x7372006cu,0x7a79006du,0x4544006eu,0x6a69006fu,0x74730070u,0x75740071u,0x62610072u,0x6f6e0073u,0x64630074u,0x66650075u,0x1000076u,0x80000009u,0x6e6d0078u,0x66650079u,0x100007au,0x80000000u,0x7473007cu,0x6a69007du,0x7574007eu,0x6a69007fu,0x706f0080u,0x6f6e0081u,0x1000082u,0x80000001u,0x66650084u,0x73720085u,0x66650086u,0x706f0087u,0x4e4d0088u,0x706f0089u,0x6564008au,0x6665008bu,0x100008cu,0x80000008u,0x6261008eu,0x6f6e008fu,0x74730090u,0x67660091u,0x706f0092u,0x73720093u,0x6e6d0094u,0x1000095u,0x80000004u,0x1000097u,0x80000003u};
      uint32_t cur = 0x76610000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   camera_perspective(DebugDevice *td, CyclesDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "perspective", paramname, paramtype, name_types);
            return;
         }
         case 1: { //position
            ANARIDataType position_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "perspective", paramname, paramtype, position_types);
            return;
         }
         case 2: { //direction
            ANARIDataType direction_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "perspective", paramname, paramtype, direction_types);
            return;
         }
         case 3: { //up
            ANARIDataType up_types[] = {ANARI_FLOAT32_VEC3, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "perspective", paramname, paramtype, up_types);
            return;
         }
         case 4: { //transform
            ANARIDataType transform_types[] = {ANARI_FLOAT32_MAT4, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "perspective", paramname, paramtype, transform_types);
            return;
         }
         case 5: { //imageRegion
            ANARIDataType imageRegion_types[] = {ANARI_FLOAT32_BOX2, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "perspective", paramname, paramtype, imageRegion_types);
            return;
         }
         case 6: { //apertureRadius
            ANARIDataType apertureRadius_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "perspective", paramname, paramtype, apertureRadius_types);
            return;
         }
         case 7: { //focusDistance
            ANARIDataType focusDistance_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "perspective", paramname, paramtype, focusDistance_types);
            return;
         }
         case 8: { //stereoMode
            ANARIDataType stereoMode_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "perspective", paramname, paramtype, stereoMode_types);
            return;
         }
         case 9: { //interpupillaryDistance
            ANARIDataType interpupillaryDistance_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "perspective", paramname, paramtype, interpupillaryDistance_types);
            return;
         }
         case 10: { //fovy
            ANARIDataType fovy_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "perspective", paramname, paramtype, fovy_types);
            return;
         }
         case 11: { //aspect
            ANARIDataType aspect_types[] = {ANARI_FLOAT32, ANARI_UNKNOWN};
            check_type(ANARI_CAMERA, "perspective", paramname, paramtype, aspect_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_CAMERA, "perspective", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "perspective";
   }
};
class geometry_triangle : public DebugObject<ANARI_GEOMETRY> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x62610009u,0x0u,0x7372000du,0x0u,0x0u,0x0u,0x0u,0x0u,0x66650044u,0x6e6d000au,0x6665000bu,0x100000cu,0x80000000u,0x6a69000eu,0x6e6d000fu,0x6a690010u,0x75740011u,0x6a690012u,0x77760013u,0x66650014u,0x2f2e0015u,0x6a610016u,0x7574001fu,0x0u,0x706f002fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x6f640034u,0x75740020u,0x73720021u,0x6a690022u,0x63620023u,0x76750024u,0x75740025u,0x66650026u,0x34300027u,0x100002bu,0x100002cu,0x100002du,0x100002eu,0x80000002u,0x80000003u,0x80000004u,0x80000005u,0x6d6c0030u,0x706f0031u,0x73720032u,0x1000033u,0x80000001u,0x100003fu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x65640040u,0x80000006u,0x66650041u,0x79780042u,0x1000043u,0x8000000eu,0x73720045u,0x75740046u,0x66650047u,0x79780048u,0x2f2e0049u,0x7161004au,0x7574005au,0x0u,0x706f006au,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x706f006fu,0x0u,0x706f0075u,0x7574005bu,0x7372005cu,0x6a69005du,0x6362005eu,0x7675005fu,0x75740060u,0x66650061u,0x34300062u,0x1000066u,0x1000067u,0x1000068u,0x1000069u,0x8000000au,0x8000000bu,0x8000000cu,0x8000000du,0x6d6c006bu,0x706f006cu,0x7372006du,0x100006eu,0x80000009u,0x73720070u,0x6e6d0071u,0x62610072u,0x6d6c0073u,0x1000074u,0x80000008u,0x74730076u,0x6a690077u,0x75740078u,0x6a690079u,0x706f007au,0x6f6e007bu,0x100007cu,0x80000007u};
      uint32_t cur = 0x776e0000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   geometry_triangle(DebugDevice *td, CyclesDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, name_types);
            return;
         }
         case 1: { //primitive.color
            ANARIDataType primitive_color_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, primitive_color_types);
            return;
         }
         case 2: { //primitive.attribute0
            ANARIDataType primitive_attribute0_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, primitive_attribute0_types);
            return;
         }
         case 3: { //primitive.attribute1
            ANARIDataType primitive_attribute1_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, primitive_attribute1_types);
            return;
         }
         case 4: { //primitive.attribute2
            ANARIDataType primitive_attribute2_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, primitive_attribute2_types);
            return;
         }
         case 5: { //primitive.attribute3
            ANARIDataType primitive_attribute3_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, primitive_attribute3_types);
            return;
         }
         case 6: { //primitive.id
            ANARIDataType primitive_id_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, primitive_id_types);
            return;
         }
         case 7: { //vertex.position
            ANARIDataType vertex_position_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, vertex_position_types);
            return;
         }
         case 8: { //vertex.normal
            ANARIDataType vertex_normal_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, vertex_normal_types);
            return;
         }
         case 9: { //vertex.color
            ANARIDataType vertex_color_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, vertex_color_types);
            return;
         }
         case 10: { //vertex.attribute0
            ANARIDataType vertex_attribute0_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, vertex_attribute0_types);
            return;
         }
         case 11: { //vertex.attribute1
            ANARIDataType vertex_attribute1_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, vertex_attribute1_types);
            return;
         }
         case 12: { //vertex.attribute2
            ANARIDataType vertex_attribute2_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, vertex_attribute2_types);
            return;
         }
         case 13: { //vertex.attribute3
            ANARIDataType vertex_attribute3_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, vertex_attribute3_types);
            return;
         }
         case 14: { //primitive.index
            ANARIDataType primitive_index_types[] = {ANARI_ARRAY1D, ANARI_UNKNOWN};
            check_type(ANARI_GEOMETRY, "triangle", paramname, paramtype, primitive_index_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_GEOMETRY, "triangle", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "triangle";
   }
};
class material_matte : public DebugObject<ANARI_MATERIAL> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x706f000cu,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610011u,0x6d6c000du,0x706f000eu,0x7372000fu,0x1000010u,0x80000001u,0x6e6d0012u,0x66650013u,0x1000014u,0x80000000u};
      uint32_t cur = 0x6f630000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   material_matte(DebugDevice *td, CyclesDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_MATERIAL, "matte", paramname, paramtype, name_types);
            return;
         }
         case 1: { //color
            ANARIDataType color_types[] = {ANARI_FLOAT32_VEC3,ANARI_SAMPLER,ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_MATERIAL, "matte", paramname, paramtype, color_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_MATERIAL, "matte", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "matte";
   }
};
class material_transparentMatte : public DebugObject<ANARI_MATERIAL> {
   static int param_hash(const char *str) {
      static const uint32_t table[] = {0x706f000du,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x62610012u,0x71700016u,0x6d6c000eu,0x706f000fu,0x73720010u,0x1000011u,0x80000001u,0x6e6d0013u,0x66650014u,0x1000015u,0x80000000u,0x62610017u,0x64630018u,0x6a690019u,0x7574001au,0x7a79001bu,0x100001cu,0x80000002u};
      uint32_t cur = 0x70630000u;
      for(int i = 0;cur!=0;++i) {
         uint32_t idx = cur&0xFFFFu;
         uint32_t low = (cur>>16u)&0xFFu;
         uint32_t high = (cur>>24u)&0xFFu;
         uint32_t c = (uint32_t)str[i];
         if(c>=low && c<high) {
            cur = table[idx+c-low];
         } else {
            break;
         }
         if(cur&0x80000000u) {
            return cur&0xFFFFu;
         }
         if(str[i]==0) {
            break;
         }
      }
      return -1;
   }
   public:
   material_transparentMatte(DebugDevice *td, CyclesDeviceDebugFactory *factory, ANARIObject wh, ANARIObject h): DebugObject(td, wh, h) { (void)factory; }
   void setParameter(const char *paramname, ANARIDataType paramtype, const void *mem) {
      DebugObject::setParameter(paramname, paramtype, mem);
      int idx = param_hash(paramname);
      switch(idx) {
         case 0: { //name
            ANARIDataType name_types[] = {ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_MATERIAL, "transparentMatte", paramname, paramtype, name_types);
            return;
         }
         case 1: { //color
            ANARIDataType color_types[] = {ANARI_FLOAT32_VEC3,ANARI_SAMPLER,ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_MATERIAL, "transparentMatte", paramname, paramtype, color_types);
            return;
         }
         case 2: { //opacity
            ANARIDataType opacity_types[] = {ANARI_FLOAT32,ANARI_SAMPLER,ANARI_STRING, ANARI_UNKNOWN};
            check_type(ANARI_MATERIAL, "transparentMatte", paramname, paramtype, opacity_types);
            return;
         }
         default: // unknown param
            unknown_parameter(ANARI_MATERIAL, "transparentMatte", paramname, paramtype);
            return;
      }
   }
   void commit() {
      DebugObject::commit();
   }
   const char* getSubtype() {
      return "transparentMatte";
   }
};
}
static int camera_object_hash(const char *str) {
   static const uint32_t table[] = {0x73720002u,0x6665000eu,0x75740003u,0x69680004u,0x706f0005u,0x68670006u,0x73720007u,0x62610008u,0x71700009u,0x6968000au,0x6a69000bu,0x6463000cu,0x100000du,0x80000000u,0x7372000fu,0x74730010u,0x71700011u,0x66650012u,0x64630013u,0x75740014u,0x6a690015u,0x77760016u,0x66650017u,0x1000018u,0x80000001u};
   uint32_t cur = 0x716f0000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = (uint32_t)str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
DebugObjectBase* CyclesDeviceDebugFactory::new_camera(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) {
   int idx = camera_object_hash(name);
   switch(idx) {
      case 0:
         return new camera_orthographic(td, this, wh, h);
      case 1:
         return new camera_perspective(td, this, wh, h);
      default:
         unknown_subtype(td, ANARI_CAMERA, name);
         return new SubtypedDebugObject<ANARI_CAMERA>(td, wh, h, name);
   }
}
static int geometry_object_hash(const char *str) {
   static const uint32_t table[] = {0x73720001u,0x6a690002u,0x62610003u,0x6f6e0004u,0x68670005u,0x6d6c0006u,0x66650007u,0x1000008u,0x80000000u};
   uint32_t cur = 0x75740000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = (uint32_t)str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
DebugObjectBase* CyclesDeviceDebugFactory::new_geometry(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) {
   int idx = geometry_object_hash(name);
   switch(idx) {
      case 0:
         return new geometry_triangle(td, this, wh, h);
      default:
         unknown_subtype(td, ANARI_GEOMETRY, name);
         return new SubtypedDebugObject<ANARI_GEOMETRY>(td, wh, h, name);
   }
}
static int material_object_hash(const char *str) {
   static const uint32_t table[] = {0x62610008u,0x0u,0x0u,0x0u,0x0u,0x0u,0x0u,0x7372000du,0x75740009u,0x7574000au,0x6665000bu,0x100000cu,0x80000000u,0x6261000eu,0x6f6e000fu,0x74730010u,0x71700011u,0x62610012u,0x73720013u,0x66650014u,0x6f6e0015u,0x75740016u,0x4e4d0017u,0x62610018u,0x75740019u,0x7574001au,0x6665001bu,0x100001cu,0x80000001u};
   uint32_t cur = 0x756d0000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = (uint32_t)str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
DebugObjectBase* CyclesDeviceDebugFactory::new_material(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) {
   int idx = material_object_hash(name);
   switch(idx) {
      case 0:
         return new material_matte(td, this, wh, h);
      case 1:
         return new material_transparentMatte(td, this, wh, h);
      default:
         unknown_subtype(td, ANARI_MATERIAL, name);
         return new SubtypedDebugObject<ANARI_MATERIAL>(td, wh, h, name);
   }
}
static int renderer_object_hash(const char *str) {
   static const uint32_t table[] = {0x66650001u,0x67660002u,0x62610003u,0x76750004u,0x6d6c0005u,0x75740006u,0x1000007u,0x80000000u};
   uint32_t cur = 0x65640000u;
   for(int i = 0;cur!=0;++i) {
      uint32_t idx = cur&0xFFFFu;
      uint32_t low = (cur>>16u)&0xFFu;
      uint32_t high = (cur>>24u)&0xFFu;
      uint32_t c = (uint32_t)str[i];
      if(c>=low && c<high) {
         cur = table[idx+c-low];
      } else {
         break;
      }
      if(cur&0x80000000u) {
         return cur&0xFFFFu;
      }
      if(str[i]==0) {
         break;
      }
   }
   return -1;
}
DebugObjectBase* CyclesDeviceDebugFactory::new_renderer(const char *name, DebugDevice *td, ANARIObject wh, ANARIObject h) {
   int idx = renderer_object_hash(name);
   switch(idx) {
      case 0:
         return new renderer_default(td, this, wh, h);
      default:
         unknown_subtype(td, ANARI_RENDERER, name);
         return new SubtypedDebugObject<ANARI_RENDERER>(td, wh, h, name);
   }
}
DebugObjectBase* CyclesDeviceDebugFactory::new_array1d(DebugDevice *td, ANARIObject wh, ANARIObject h) {
   return new array1d(td, this, wh, h);
}
DebugObjectBase* CyclesDeviceDebugFactory::new_array2d(DebugDevice *td, ANARIObject wh, ANARIObject h) {
   return new array2d(td, this, wh, h);
}
DebugObjectBase* CyclesDeviceDebugFactory::new_array3d(DebugDevice *td, ANARIObject wh, ANARIObject h) {
   return new array3d(td, this, wh, h);
}
DebugObjectBase* CyclesDeviceDebugFactory::new_device(DebugDevice *td, ANARIObject wh, ANARIObject h) {
   return new device(td, this, wh, h);
}
DebugObjectBase* CyclesDeviceDebugFactory::new_frame(DebugDevice *td, ANARIObject wh, ANARIObject h) {
   return new frame(td, this, wh, h);
}
DebugObjectBase* CyclesDeviceDebugFactory::new_group(DebugDevice *td, ANARIObject wh, ANARIObject h) {
   return new group(td, this, wh, h);
}
DebugObjectBase* CyclesDeviceDebugFactory::new_instance(DebugDevice *td, ANARIObject wh, ANARIObject h) {
   return new instance(td, this, wh, h);
}
DebugObjectBase* CyclesDeviceDebugFactory::new_surface(DebugDevice *td, ANARIObject wh, ANARIObject h) {
   return new surface(td, this, wh, h);
}
DebugObjectBase* CyclesDeviceDebugFactory::new_world(DebugDevice *td, ANARIObject wh, ANARIObject h) {
   return new world(td, this, wh, h);
}
void CyclesDeviceDebugFactory::print_summary(DebugDevice *td) {
   (void)td;
}
anari::debug_device::ObjectFactory* getDebugFactory() {
   static CyclesDeviceDebugFactory f;
   return &f;
}
}
